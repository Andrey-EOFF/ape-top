{"version":3,"file":"static/js/654.f1d58bc9.chunk.js","mappings":"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","sources":["Components/Arts/Arts.styled.jsx","Components/Data/ArtsData.jsx","Components/Arts/Arts.jsx","../node_modules/react-swipeable/src/types.ts","../node_modules/react-swipeable/src/index.ts"],"sourcesContent":["import styled from \"styled-components\";\r\nimport { Colors, SizeDev } from \"../styles/ConstantStyles\";\r\n\r\nexport const ArtsSection = styled.section`\r\n  overflow: hidden;\r\n  border: none;\r\n  background-color: transparent;\r\n  padding-top: 60px;\r\n\r\n  @media (min-width: ${SizeDev.TAB}) {\r\n    padding-top: 80px;\r\n  }\r\n\r\n  @media (min-width: ${SizeDev.DESK}) {\r\n    padding-top: 120px;\r\n  }\r\n`;\r\n\r\nexport const ArtTitle = styled.h2`\r\n  margin-bottom: 24px;\r\n\r\n  color: ${Colors.ColorWhite};\r\n\r\n  font-family: \"Right Grotesk Compact\";\r\n  font-size: 44px;\r\n  font-weight: 900;\r\n  line-height: 1;\r\n  text-align: center;\r\n\r\n  @media (min-width: ${SizeDev.TAB}) {\r\n    margin-bottom: 40px;\r\n    font-size: 80px;\r\n    font-weight: 900;\r\n    line-height: 1;\r\n  }\r\n\r\n  @media (min-width: ${SizeDev.DESK}) {\r\n    margin-bottom: 80px;\r\n    font-size: 160px;\r\n    font-weight: 900;\r\n    line-height: 1;\r\n  }\r\n`;\r\n\r\nexport const ArtsSlider = styled.div`\r\n  gap: 24px;\r\n  display: flex;\r\n  transition: transform 0.5s ease;\r\n  overflow: hidden;\r\n`;\r\n\r\nexport const ArtSlide = styled.img`\r\n  flex: 0 0 auto;\r\n  width: 215px;\r\n  height: 256px;\r\n\r\n  @media (min-width: ${SizeDev.TAB}) {\r\n    width: 284px;\r\n    height: 336px;\r\n  }\r\n  @media (min-width: ${SizeDev.DESK}) {\r\n    width: 240px;\r\n    height: 280px;\r\n  }\r\n`;\r\n\r\nexport const PrevNextButtons = styled.div`\r\n  display: flex;\r\n  justify-content: space-between;\r\n\r\n  width: 150px;\r\n  margin-top: 24px;\r\n\r\n  margin-left: auto;\r\n  margin-right: auto;\r\n\r\n  button {\r\n    border: none;\r\n    background-color: transparent;\r\n    color: ${Colors.ColorWhite};\r\n    font-family: \"Biro Script Plus Bold US\";\r\n    font-size: 24px;\r\n    font-weight: 400;\r\n    line-height: 1;\r\n    text-align: center;\r\n\r\n    cursor: pointer;\r\n  }\r\n`;\r\n","import ArtImg1 from \"../../Images/Png/ape-1.png\";\r\nimport ArtImg2 from \"../../Images/Png/ape-2.png\";\r\nimport ArtImg3 from \"../../Images/Png/ape-3.png\";\r\nimport ArtImg4 from \"../../Images/Png/ape-4.png\";\r\nimport ArtImg5 from \"../../Images/Png/ape-5.png\";\r\nimport ArtImg6 from \"../../Images/Png/ape-6.png\";\r\nimport ArtImg7 from \"../../Images/Png/ape-7.png\";\r\nimport ArtImg8 from \"../../Images/Png/ape-8.png\";\r\nimport ArtImg9 from \"../../Images/Png/ape-9.png\";\r\nimport ArtImg10 from \"../../Images/Png/ape-10.png\";\r\nimport ArtImg11 from \"../../Images/Png/ape-11.png\";\r\n\r\nexport const ArtSlides = [\r\n  ArtImg1,\r\n  ArtImg2,\r\n  ArtImg3,\r\n  ArtImg4,\r\n  ArtImg5,\r\n  ArtImg6,\r\n  ArtImg7,\r\n  ArtImg8,\r\n  ArtImg9,\r\n  ArtImg10,\r\n  ArtImg11,\r\n];\r\n","import React, { useEffect, useState } from \"react\";\r\nimport { useSwipeable } from \"react-swipeable\";\r\nimport {\r\n  ArtsSection,\r\n  ArtsSlider,\r\n  ArtSlide,\r\n  PrevNextButtons,\r\n  ArtTitle,\r\n} from \"./Arts.styled\";\r\nimport { ArtSlides } from \"../Data/ArtsData\";\r\n\r\nconst Arts = () => {\r\n  const [currentSlide, setCurrentSlide] = useState(0);\r\n  const [slidesPerPage, setSlidesPerPage] = useState(1);\r\n  const [totalSlides, setTotalSlides] = useState(0);\r\n\r\n  const handlePrev = () => {\r\n    setCurrentSlide((prevSlide) =>\r\n      prevSlide === 0 ? prevSlide : prevSlide - 1\r\n    );\r\n  };\r\n\r\n  const handleNext = () => {\r\n    setCurrentSlide((prevSlide) =>\r\n      prevSlide === totalSlides - 1 ? prevSlide : prevSlide + 1\r\n    );\r\n  };\r\n\r\n  const swipeHandlers = useSwipeable({\r\n    onSwipedLeft: handleNext,\r\n    onSwipedRight: handlePrev,\r\n  });\r\n\r\n  const handleKeyDown = (e) => {\r\n    if (e.key === \"ArrowLeft\") handlePrev();\r\n    else if (e.key === \"ArrowRight\") handleNext();\r\n  };\r\n\r\n  const SlidesPerPage = () => {\r\n    const screenWidth = window.innerWidth;\r\n    if (screenWidth >= 1024) {\r\n      setSlidesPerPage(4);\r\n    } else if (screenWidth >= 768) {\r\n      setSlidesPerPage(2);\r\n    } else {\r\n      setSlidesPerPage(1);\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    SlidesPerPage();\r\n    setTotalSlides(ArtSlides.length);\r\n    window.addEventListener(\"resize\", SlidesPerPage);\r\n    return () => {\r\n      window.removeEventListener(\"resize\", SlidesPerPage);\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <ArtsSection\r\n      id=\"arts\"\r\n      {...swipeHandlers}\r\n      tabIndex={0}\r\n      onKeyDown={handleKeyDown}\r\n    >\r\n      <ArtTitle>COLLECTION</ArtTitle>\r\n      <ArtsSlider>\r\n        {ArtSlides.map((slide, index) => (\r\n          <ArtSlide\r\n            key={index}\r\n            src={slide}\r\n            alt={`Art ${index}`}\r\n            aria-hidden={index !== currentSlide}\r\n            style={{\r\n              display:\r\n                index >= currentSlide && index < currentSlide + slidesPerPage\r\n                  ? \"block\"\r\n                  : \"none\",\r\n            }}\r\n          />\r\n        ))}\r\n      </ArtsSlider>\r\n      <PrevNextButtons>\r\n        <button onClick={handlePrev} disabled={currentSlide === 0}>\r\n          Prev\r\n        </button>\r\n        <button\r\n          onClick={handleNext}\r\n          disabled={currentSlide === totalSlides - slidesPerPage}\r\n        >\r\n          Next\r\n        </button>\r\n      </PrevNextButtons>\r\n    </ArtsSection>\r\n  );\r\n};\r\n\r\nexport default Arts;\r\n","import * as React from \"react\";\n\nexport const LEFT = \"Left\";\nexport const RIGHT = \"Right\";\nexport const UP = \"Up\";\nexport const DOWN = \"Down\";\nexport type HandledEvents = React.MouseEvent | TouchEvent | MouseEvent;\nexport type Vector2 = [number, number];\nexport type SwipeDirections =\n  | typeof LEFT\n  | typeof RIGHT\n  | typeof UP\n  | typeof DOWN;\nexport interface SwipeEventData {\n  /**\n   * Absolute displacement of swipe in x. Math.abs(deltaX);\n   */\n  absX: number;\n  /**\n   * Absolute displacement of swipe in y. Math.abs(deltaY);\n   */\n  absY: number;\n  /**\n   * Displacement of swipe in x. (current.x - initial.x)\n   */\n  deltaX: number;\n  /**\n   * Displacement of swipe in y. (current.y - initial.y)\n   */\n  deltaY: number;\n  /**\n   * Direction of swipe - Left | Right | Up | Down\n   */\n  dir: SwipeDirections;\n  /**\n   * Source event.\n   */\n  event: HandledEvents;\n  /**\n   * True for the first event of a tracked swipe.\n   */\n  first: boolean;\n  /**\n   * Location where swipe started - [x, y].\n   */\n  initial: Vector2;\n  /**\n   * \"Absolute velocity\" (speed) - âˆš(absX^2 + absY^2) / time\n   */\n  velocity: number;\n  /**\n   * Velocity per axis - [ deltaX/time, deltaY/time ]\n   */\n  vxvy: Vector2;\n}\n\nexport type SwipeCallback = (eventData: SwipeEventData) => void;\nexport type TapCallback = ({ event }: { event: HandledEvents }) => void;\n\nexport type SwipeableDirectionCallbacks = {\n  /**\n   * Called after a DOWN swipe\n   */\n  onSwipedDown: SwipeCallback;\n  /**\n   * Called after a LEFT swipe\n   */\n  onSwipedLeft: SwipeCallback;\n  /**\n   * Called after a RIGHT swipe\n   */\n  onSwipedRight: SwipeCallback;\n  /**\n   * Called after a UP swipe\n   */\n  onSwipedUp: SwipeCallback;\n};\n\nexport type SwipeableCallbacks = SwipeableDirectionCallbacks & {\n  /**\n   * Called at start of a tracked swipe.\n   */\n  onSwipeStart: SwipeCallback;\n  /**\n   * Called after any swipe.\n   */\n  onSwiped: SwipeCallback;\n  /**\n   * Called for each move event during a tracked swipe.\n   */\n  onSwiping: SwipeCallback;\n  /**\n   * Called after a tap. A touch under the min distance, `delta`.\n   */\n  onTap: TapCallback;\n  /**\n   * Called for `touchstart` and `mousedown`.\n   */\n  onTouchStartOrOnMouseDown: TapCallback;\n  /**\n   * Called for `touchend` and `mouseup`.\n   */\n  onTouchEndOrOnMouseUp: TapCallback;\n};\n\n// Configuration Options\nexport type ConfigurationOptionDelta =\n  | number\n  | { [key in Lowercase<SwipeDirections>]?: number };\n\nexport interface ConfigurationOptions {\n  /**\n   * Min distance(px) before a swipe starts. **Default**: `10`\n   */\n  delta: ConfigurationOptionDelta;\n  /**\n   * Prevents scroll during swipe in most cases. **Default**: `false`\n   */\n  preventScrollOnSwipe: boolean;\n  /**\n   * Set a rotation angle. **Default**: `0`\n   */\n  rotationAngle: number;\n  /**\n   * Track mouse input. **Default**: `false`\n   */\n  trackMouse: boolean;\n  /**\n   * Track touch input. **Default**: `true`\n   */\n  trackTouch: boolean;\n  /**\n   * Allowable duration of a swipe (ms). **Default**: `Infinity`\n   */\n  swipeDuration: number;\n  /**\n   * Options for touch event listeners\n   */\n  touchEventOptions: { passive: boolean };\n}\n\nexport type SwipeableProps = Partial<SwipeableCallbacks & ConfigurationOptions>;\n\nexport type SwipeablePropsWithDefaultOptions = Partial<SwipeableCallbacks> &\n  ConfigurationOptions;\n\nexport interface SwipeableHandlers {\n  ref(element: HTMLElement | null): void;\n  onMouseDown?(event: React.MouseEvent): void;\n}\n\nexport type SwipeableState = {\n  cleanUpTouch?: () => void;\n  el?: HTMLElement;\n  eventData?: SwipeEventData;\n  first: boolean;\n  initial: Vector2;\n  start: number;\n  swiping: boolean;\n  xy: Vector2;\n};\n\nexport type StateSetter = (\n  state: SwipeableState,\n  props: SwipeablePropsWithDefaultOptions\n) => SwipeableState;\nexport type Setter = (stateSetter: StateSetter) => void;\nexport type AttachTouch = (\n  el: HTMLElement,\n  props: SwipeablePropsWithDefaultOptions\n) => () => void;\n","/* global document */\nimport * as React from \"react\";\nimport {\n  AttachTouch,\n  SwipeDirections,\n  DOWN,\n  SwipeEventData,\n  HandledEvents,\n  LEFT,\n  RIGHT,\n  Setter,\n  ConfigurationOptions,\n  SwipeableDirectionCallbacks,\n  SwipeableHandlers,\n  SwipeableProps,\n  SwipeablePropsWithDefaultOptions,\n  SwipeableState,\n  SwipeCallback,\n  TapCallback,\n  UP,\n  Vector2,\n} from \"./types\";\n\nexport {\n  LEFT,\n  RIGHT,\n  UP,\n  DOWN,\n  SwipeDirections,\n  SwipeEventData,\n  SwipeableDirectionCallbacks,\n  SwipeCallback,\n  TapCallback,\n  SwipeableHandlers,\n  SwipeableProps,\n  Vector2,\n};\n\nconst defaultProps: ConfigurationOptions = {\n  delta: 10,\n  preventScrollOnSwipe: false,\n  rotationAngle: 0,\n  trackMouse: false,\n  trackTouch: true,\n  swipeDuration: Infinity,\n  touchEventOptions: { passive: true },\n};\nconst initialState: SwipeableState = {\n  first: true,\n  initial: [0, 0],\n  start: 0,\n  swiping: false,\n  xy: [0, 0],\n};\nconst mouseMove = \"mousemove\";\nconst mouseUp = \"mouseup\";\nconst touchEnd = \"touchend\";\nconst touchMove = \"touchmove\";\nconst touchStart = \"touchstart\";\n\nfunction getDirection(\n  absX: number,\n  absY: number,\n  deltaX: number,\n  deltaY: number\n): SwipeDirections {\n  if (absX > absY) {\n    if (deltaX > 0) {\n      return RIGHT;\n    }\n    return LEFT;\n  } else if (deltaY > 0) {\n    return DOWN;\n  }\n  return UP;\n}\n\nfunction rotateXYByAngle(pos: Vector2, angle: number): Vector2 {\n  if (angle === 0) return pos;\n  const angleInRadians = (Math.PI / 180) * angle;\n  const x =\n    pos[0] * Math.cos(angleInRadians) + pos[1] * Math.sin(angleInRadians);\n  const y =\n    pos[1] * Math.cos(angleInRadians) - pos[0] * Math.sin(angleInRadians);\n  return [x, y];\n}\n\nfunction getHandlers(\n  set: Setter,\n  handlerProps: { trackMouse: boolean | undefined }\n): [\n  {\n    ref: (element: HTMLElement | null) => void;\n    onMouseDown?: (event: React.MouseEvent) => void;\n  },\n  AttachTouch\n] {\n  const onStart = (event: HandledEvents) => {\n    const isTouch = \"touches\" in event;\n    // if more than a single touch don't track, for now...\n    if (isTouch && event.touches.length > 1) return;\n\n    set((state, props) => {\n      // setup mouse listeners on document to track swipe since swipe can leave container\n      if (props.trackMouse && !isTouch) {\n        document.addEventListener(mouseMove, onMove);\n        document.addEventListener(mouseUp, onUp);\n      }\n      const { clientX, clientY } = isTouch ? event.touches[0] : event;\n      const xy = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n\n      props.onTouchStartOrOnMouseDown &&\n        props.onTouchStartOrOnMouseDown({ event });\n\n      return {\n        ...state,\n        ...initialState,\n        initial: xy.slice() as Vector2,\n        xy,\n        start: event.timeStamp || 0,\n      };\n    });\n  };\n\n  const onMove = (event: HandledEvents) => {\n    set((state, props) => {\n      const isTouch = \"touches\" in event;\n      // Discount a swipe if additional touches are present after\n      // a swipe has started.\n      if (isTouch && event.touches.length > 1) {\n        return state;\n      }\n\n      // if swipe has exceeded duration stop tracking\n      if (event.timeStamp - state.start > props.swipeDuration) {\n        return state.swiping ? { ...state, swiping: false } : state;\n      }\n\n      const { clientX, clientY } = isTouch ? event.touches[0] : event;\n      const [x, y] = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n      const deltaX = x - state.xy[0];\n      const deltaY = y - state.xy[1];\n      const absX = Math.abs(deltaX);\n      const absY = Math.abs(deltaY);\n      const time = (event.timeStamp || 0) - state.start;\n      const velocity = Math.sqrt(absX * absX + absY * absY) / (time || 1);\n      const vxvy: Vector2 = [deltaX / (time || 1), deltaY / (time || 1)];\n\n      const dir = getDirection(absX, absY, deltaX, deltaY);\n\n      // if swipe is under delta and we have not started to track a swipe: skip update\n      const delta =\n        typeof props.delta === \"number\"\n          ? props.delta\n          : props.delta[dir.toLowerCase() as Lowercase<SwipeDirections>] ||\n            defaultProps.delta;\n      if (absX < delta && absY < delta && !state.swiping) return state;\n\n      const eventData = {\n        absX,\n        absY,\n        deltaX,\n        deltaY,\n        dir,\n        event,\n        first: state.first,\n        initial: state.initial,\n        velocity,\n        vxvy,\n      };\n\n      // call onSwipeStart if present and is first swipe event\n      eventData.first && props.onSwipeStart && props.onSwipeStart(eventData);\n\n      // call onSwiping if present\n      props.onSwiping && props.onSwiping(eventData);\n\n      // track if a swipe is cancelable (handler for swiping or swiped(dir) exists)\n      // so we can call preventDefault if needed\n      let cancelablePageSwipe = false;\n      if (\n        props.onSwiping ||\n        props.onSwiped ||\n        props[`onSwiped${dir}` as keyof SwipeableDirectionCallbacks]\n      ) {\n        cancelablePageSwipe = true;\n      }\n\n      if (\n        cancelablePageSwipe &&\n        props.preventScrollOnSwipe &&\n        props.trackTouch &&\n        event.cancelable\n      ) {\n        event.preventDefault();\n      }\n\n      return {\n        ...state,\n        // first is now always false\n        first: false,\n        eventData,\n        swiping: true,\n      };\n    });\n  };\n\n  const onEnd = (event: HandledEvents) => {\n    set((state, props) => {\n      let eventData: SwipeEventData | undefined;\n      if (state.swiping && state.eventData) {\n        // if swipe is less than duration fire swiped callbacks\n        if (event.timeStamp - state.start < props.swipeDuration) {\n          eventData = { ...state.eventData, event };\n          props.onSwiped && props.onSwiped(eventData);\n\n          const onSwipedDir =\n            props[\n              `onSwiped${eventData.dir}` as keyof SwipeableDirectionCallbacks\n            ];\n          onSwipedDir && onSwipedDir(eventData);\n        }\n      } else {\n        props.onTap && props.onTap({ event });\n      }\n\n      props.onTouchEndOrOnMouseUp && props.onTouchEndOrOnMouseUp({ event });\n\n      return { ...state, ...initialState, eventData };\n    });\n  };\n\n  const cleanUpMouse = () => {\n    // safe to just call removeEventListener\n    document.removeEventListener(mouseMove, onMove);\n    document.removeEventListener(mouseUp, onUp);\n  };\n\n  const onUp = (e: HandledEvents) => {\n    cleanUpMouse();\n    onEnd(e);\n  };\n\n  /**\n   * The value of passive on touchMove depends on `preventScrollOnSwipe`:\n   * - true => { passive: false }\n   * - false => { passive: true } // Default\n   *\n   * NOTE: When preventScrollOnSwipe is true, we attempt to call preventDefault to prevent scroll.\n   *\n   * props.touchEventOptions can also be set for all touch event listeners,\n   * but for `touchmove` specifically when `preventScrollOnSwipe` it will\n   * supersede and force passive to false.\n   *\n   */\n  const attachTouch: AttachTouch = (el, props) => {\n    let cleanup = () => {};\n    if (el && el.addEventListener) {\n      const baseOptions = {\n        ...defaultProps.touchEventOptions,\n        ...props.touchEventOptions,\n      };\n      // attach touch event listeners and handlers\n      const tls: [\n        typeof touchStart | typeof touchMove | typeof touchEnd,\n        (e: HandledEvents) => void,\n        { passive: boolean }\n      ][] = [\n        [touchStart, onStart, baseOptions],\n        // preventScrollOnSwipe option supersedes touchEventOptions.passive\n        [\n          touchMove,\n          onMove,\n          {\n            ...baseOptions,\n            ...(props.preventScrollOnSwipe ? { passive: false } : {}),\n          },\n        ],\n        [touchEnd, onEnd, baseOptions],\n      ];\n      tls.forEach(([e, h, o]) => el.addEventListener(e, h, o));\n      // return properly scoped cleanup method for removing listeners, options not required\n      cleanup = () => tls.forEach(([e, h]) => el.removeEventListener(e, h));\n    }\n    return cleanup;\n  };\n\n  const onRef = (el: HTMLElement | null) => {\n    // \"inline\" ref functions are called twice on render, once with null then again with DOM element\n    // ignore null here\n    if (el === null) return;\n    set((state, props) => {\n      // if the same DOM el as previous just return state\n      if (state.el === el) return state;\n\n      const addState: { cleanUpTouch?: () => void } = {};\n      // if new DOM el clean up old DOM and reset cleanUpTouch\n      if (state.el && state.el !== el && state.cleanUpTouch) {\n        state.cleanUpTouch();\n        addState.cleanUpTouch = void 0;\n      }\n      // only attach if we want to track touch\n      if (props.trackTouch && el) {\n        addState.cleanUpTouch = attachTouch(el, props);\n      }\n\n      // store event attached DOM el for comparison, clean up, and re-attachment\n      return { ...state, el, ...addState };\n    });\n  };\n\n  // set ref callback to attach touch event listeners\n  const output: { ref: typeof onRef; onMouseDown?: typeof onStart } = {\n    ref: onRef,\n  };\n\n  // if track mouse attach mouse down listener\n  if (handlerProps.trackMouse) {\n    output.onMouseDown = onStart;\n  }\n\n  return [output, attachTouch];\n}\n\nfunction updateTransientState(\n  state: SwipeableState,\n  props: SwipeablePropsWithDefaultOptions,\n  previousProps: SwipeablePropsWithDefaultOptions,\n  attachTouch: AttachTouch\n) {\n  // if trackTouch is off or there is no el, then remove handlers if necessary and exit\n  if (!props.trackTouch || !state.el) {\n    if (state.cleanUpTouch) {\n      state.cleanUpTouch();\n    }\n\n    return {\n      ...state,\n      cleanUpTouch: undefined,\n    };\n  }\n\n  // trackTouch is on, so if there are no handlers attached, attach them and exit\n  if (!state.cleanUpTouch) {\n    return {\n      ...state,\n      cleanUpTouch: attachTouch(state.el, props),\n    };\n  }\n\n  // trackTouch is on and handlers are already attached, so if preventScrollOnSwipe changes value,\n  // remove and reattach handlers (this is required to update the passive option when attaching\n  // the handlers)\n  if (\n    props.preventScrollOnSwipe !== previousProps.preventScrollOnSwipe ||\n    props.touchEventOptions.passive !== previousProps.touchEventOptions.passive\n  ) {\n    state.cleanUpTouch();\n\n    return {\n      ...state,\n      cleanUpTouch: attachTouch(state.el, props),\n    };\n  }\n\n  return state;\n}\n\nexport function useSwipeable(options: SwipeableProps): SwipeableHandlers {\n  const { trackMouse } = options;\n  const transientState = React.useRef({ ...initialState });\n  const transientProps = React.useRef<SwipeablePropsWithDefaultOptions>({\n    ...defaultProps,\n  });\n\n  // track previous rendered props\n  const previousProps = React.useRef<SwipeablePropsWithDefaultOptions>({\n    ...transientProps.current,\n  });\n  previousProps.current = { ...transientProps.current };\n\n  // update current render props & defaults\n  transientProps.current = {\n    ...defaultProps,\n    ...options,\n  };\n  // Force defaults for config properties\n  let defaultKey: keyof ConfigurationOptions;\n  for (defaultKey in defaultProps) {\n    if (transientProps.current[defaultKey] === void 0) {\n      (transientProps.current[defaultKey] as any) = defaultProps[defaultKey];\n    }\n  }\n\n  const [handlers, attachTouch] = React.useMemo(\n    () =>\n      getHandlers(\n        (stateSetter) =>\n          (transientState.current = stateSetter(\n            transientState.current,\n            transientProps.current\n          )),\n        { trackMouse }\n      ),\n    [trackMouse]\n  );\n\n  transientState.current = updateTransientState(\n    transientState.current,\n    transientProps.current,\n    previousProps.current,\n    attachTouch\n  );\n\n  return handlers;\n}\n"],"names":["ArtsSection","styled","section","_templateObject","_taggedTemplateLiteral","SizeDev","TAB","DESK","ArtTitle","h2","_templateObject2","Colors","ColorWhite","ArtsSlider","div","_templateObject3","ArtSlide","img","_templateObject4","PrevNextButtons","_templateObject5","ArtSlides","Arts","currentSlide","setCurrentSlide","useState","slidesPerPage","setSlidesPerPage","totalSlides","setTotalSlides","handlePrev","prevSlide","handleNext","swipeHandlers","useSwipeable","onSwipedLeft","onSwipedRight","SlidesPerPage","screenWidth","window","innerWidth","useEffect","length","addEventListener","removeEventListener","_jsxs","id","tabIndex","onKeyDown","e","key","children","_jsx","map","slide","index","src","alt","concat","style","display","onClick","disabled","LEFT","RIGHT","UP","DOWN","defaultProps","delta","preventScrollOnSwipe","rotationAngle","trackMouse","trackTouch","swipeDuration","Infinity","touchEventOptions","passive","initialState","first","initial","start","swiping","xy","mouseMove","mouseUp","touchEnd","touchMove","touchStart","rotateXYByAngle","pos","angle","angleInRadians","Math","PI","cos","sin","getHandlers","set","handlerProps","onStart","event","isTouch","touches","state","props","document","onMove","onUp","clientX","clientY","onTouchStartOrOnMouseDown","Object","assign","slice","timeStamp","x","y","deltaX","deltaY","absX","abs","absY","time","velocity","sqrt","vxvy","dir","getDirection","toLowerCase","eventData","onSwipeStart","onSwiping","cancelablePageSwipe","onSwiped","cancelable","preventDefault","onEnd","onSwipedDir","onTap","onTouchEndOrOnMouseUp","attachTouch","el","cleanup","baseOptions","tls","forEach","_ref","h","o","_ref2","output","ref","addState","cleanUpTouch","onMouseDown","options","transientState","React","transientProps","previousProps","current","defaultKey","handlers","stateSetter","undefined","updateTransientState"],"sourceRoot":""}